# オーディオ再生実装計画

## 概要
このドキュメントは、cat-play-mmlの機能と同様に、cat-edit-mml TUIエディタにリアルタイムMML（Music Macro Language）再生を統合する計画を概説します。

## 現在の状況
- ✅ ratatui、tui-textarea、crosstermを使用した基本的なTUIエディタの実装完了
- ✅ 複数行テキスト入力とカーソル移動が動作
- ✅ ESCキーでアプリケーション終了
- ⏳ オーディオ再生機能は保留中

## 必要な依存関係
cat-play-mmlから以下のクレートを統合する必要があります：

```toml
mmlabc-to-smf = { git = "https://github.com/cat2151/mmlabc-to-smf-rust" }
smf-to-ym2151log-rust = { git = "https://github.com/cat2151/smf-to-ym2151log-rust" }
ym2151-log-player-rust = { git = "https://github.com/cat2151/ym2151-log-player-rust", features = ["realtime-audio"] }
serde_json = "1.0"
```

## 実装戦略

### フェーズ1: オーディオシステムの統合
1. **オーディオ依存関係の追加** - Cargo.tomlへ（プラットフォーム固有の要件により現在はコメントアウト）
2. **オーディオモジュールの作成** (`src/audio.rs`)に以下を含む：
   - MMLからオーディオへの変換パイプライン
   - バックグラウンドオーディオ再生スレッド管理
   - オーディオ初期化失敗時の適切なエラー処理

### フェーズ2: エディタ統合
1. **デバウンス付き再生トリガー**
   - キーストロークごとの再生を防ぐタイマーを追加
   - 編集後500-1000msのアイドル時間後に再生をトリガー
   - 新しい編集が発生したら進行中の再生をキャンセル

2. **バックグラウンドオーディオスレッド**
   - オーディオ処理用の個別スレッドを生成
   - エディタとオーディオスレッド間の通信にチャネル（mpsc）を使用
   - 編集されたMMLコンテンツをオーディオスレッドに送信して処理

3. **UIステータスインジケータ**
   - エディタの枠線タイトルに再生ステータスを表示
   - MML解析または再生が失敗した場合はエラーを表示
   - 現在の再生状態を表示（アイドル、再生中、エラー）

### フェーズ3: エラー処理
1. **グレースフルデグラデーション**
   - オーディオ初期化が失敗してもテキストエディタとして動作を継続
   - オーディオ利用不可についての警告メッセージを表示
   - クラッシュせずにオーディオエラーをstderrにログ

2. **MML検証**
   - mmlabc-to-smfからの解析エラーをキャッチ
   - UIにエラーメッセージを表示
   - 無効なMMLでも編集を継続可能に

## コード構造

### 提案されるファイル構造
```
src/
├── main.rs          # メインエントリポイントとイベントループ
├── audio.rs         # オーディオ再生モジュール
├── editor.rs        # エディタの状態とUI（オプションのリファクタ）
└── config.rs        # 設定（デバウンス時間など）
```

### 主要コンポーネント

#### オーディオモジュール (`src/audio.rs`)
```rust
pub struct AudioSystem {
    sender: mpsc::Sender<AudioCommand>,
    thread_handle: JoinHandle<()>,
}

pub enum AudioCommand {
    Play(String),  // 再生するMMLコンテンツ
    Stop,
    Shutdown,
}

impl AudioSystem {
    pub fn new() -> Result<Self>;
    pub fn play_mml(&self, mml: &str);
    pub fn stop(&self);
}
```

#### メインイベントループ統合
```rust
// main.rsの疑似コード
let mut audio_system = AudioSystem::new().ok(); // オプションのオーディオ
let mut last_edit_time = Instant::now();
let mut last_content = String::new();

loop {
    terminal.draw(...)?;
    
    if event::poll(Duration::from_millis(100))? {
        match event::read()? {
            Event::Key(key) => {
                if key.code == KeyCode::Esc { break; }
                textarea.input(key);
                last_edit_time = Instant::now();
            }
        }
    }
    
    // デバウンス付き再生トリガー
    if last_edit_time.elapsed() > Duration::from_millis(500) {
        let content = textarea.lines().join("\n");
        if content != last_content {
            if let Some(audio) = &audio_system {
                audio.play_mml(&content);
            }
            last_content = content;
        }
    }
}
```

## プラットフォーム考慮事項

### Windows（対象プラットフォーム）
- cpal経由でWASAPIバックエンドを使用
- 追加のシステム依存関係なしで動作するはず
- 最終デプロイ前にWindowsでテスト

### Linux（開発環境）
- ALSA開発ライブラリ（`libalsa-dev`パッケージ）が必要
- 追加のオーディオシステム依存関係が必要な場合あり
- 開発中はオーディオをオプションにするためにfeatureフラグを使用

### macOS
- cpal経由でCoreAudioバックエンドを使用
- 追加の依存関係なしで動作するはず

## テスト計画

1. **ユニットテスト**
   - 有効/無効な入力でMML解析をテスト
   - オーディオコマンドチャネル通信をテスト
   - デバウンスロジックをテスト

2. **統合テスト**
   - 完全なMML→オーディオパイプラインをテスト
   - オーディオなしでのグレースフルデグラデーションをテスト
   - オーディオ失敗時もエディタが動作し続けることをテスト

3. **手動テスト**
   - Windows対象プラットフォームでテスト
   - 様々なMMLスニペットでテスト
   - 大きなMMLファイルでのパフォーマンステスト
   - 高速編集動作のテスト

## パフォーマンス考慮事項

1. **メモリ使用量**
   - オーディオバッファサイズを制限
   - 新しい再生を開始する前に前の再生をクリーンアップ
   - 大きなMMLファイルにはストリーミングを検討

2. **CPU使用率**
   - オーディオ処理を別スレッドで実行
   - デバウンスを使用して過剰な処理を回避
   - テスト用に再生時間の制限を検討

3. **応答性**
   - 再生中もUIが応答性を維持することを確保
   - 再生キャンセルを許可
   - オーディオ操作でブロックしない

## 代替アプローチ

リアルタイム再生が複雑すぎる場合：

1. **保存して再生モード**
   - 現在のコンテンツを保存して再生するコマンドを追加
   - 外部プレイヤー（cat-play-mmlバイナリなど）を使用
   - よりシンプルな統合、リアルタイム性は低い

2. **プレビューモード**
   - モード切り替え（編集/プレビュー）を追加
   - プレビューモードでのみ再生
   - 関心事の明確な分離

3. **構文検証のみ**
   - MML構文の検証のみ
   - エラーは表示するが再生しない
   - エディタの品質に焦点

## タイムライン見積もり

- フェーズ1（オーディオ統合）：4-8時間
- フェーズ2（エディタ統合）：4-6時間
- フェーズ3（エラー処理）：2-4時間
- テストと改良：4-6時間

**合計**: 14-24時間の開発時間

## 依存関係とブロッカー

- **Windowsテスト環境**: 最終テスト用のWindowsへのアクセスが必要
- **オーディオハードウェア**: 対象システムで動作するオーディオ出力が必要
- **プラットフォームライブラリ**: LinuxではALSA、WindowsではWASAPI
- **Git依存関係**: cat-play-mmlクレートをダウンロードするためのネットワークアクセス

## 成功基準

✅ オーディオサポートの有無にかかわらずエディタが正常に起動
✅ 複数行編集がスムーズに動作
✅ 編集後に自動的にオーディオが再生される（デバウンス付き）
✅ エラーが適切に処理される
✅ パフォーマンスが許容範囲（入力中のラグなし）
✅ Windows対象プラットフォームで動作

## 次のステップ

1. Cargo.tomlでオーディオfeatureフラグを有効化
2. 基本的な再生機能を持つオーディオモジュールを実装
3. メインイベントループにデバウンスロジックを追加
4. Linux開発環境でテスト
5. Windows対象環境でテスト
6. パフォーマンスと使いやすさのフィードバックに基づいて改良
